import { createStep } from '@mastra/core/workflows';
import { z } from 'zod';
import { buildHeaders, throwIfNotOk } from './utils.js';

const resolveToken = (inputToken?: string): string | undefined => {
  return (
    inputToken ||
    process.env.GITHUB_MCP_PAT ||
    undefined
  );
};

// Step 7: Open PR (to dev if it exists; fallback to default branch)
export const openPr = createStep({
  id: 'open-pr',
  description: 'Open a PR to default branch',
  inputSchema: z.object({
    runId: z.string(),
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
    candidatePath: z.string(),
    commitSha: z.string(),
    newSha: z.string(),
    token: z.string().optional(),
    prTitle: z.string().optional(),
    prBody: z.string().optional(),
  }),
  outputSchema: z.object({
    runId: z.string(),
    owner: z.string(),
    repo: z.string(),
    branch: z.string(),
    token: z.string().optional(),
    number: z.number(),
    url: z.string(),
    state: z.string(),
  }),
  execute: async ({ inputData }) => {
    const token = resolveToken(inputData?.token);
    try { console.log('[samba/open-pr] in', { runId: inputData.runId, branch: inputData.branch, owner: inputData.owner, repo: inputData.repo }); } catch {}
    const repoUrl = `https://api.github.com/repos/${encodeURIComponent(inputData.owner)}/${encodeURIComponent(inputData.repo)}`;
    const repoRes = await fetch(repoUrl, { headers: buildHeaders(token, false) });
    await throwIfNotOk(repoRes);
    const repoData = await repoRes.json();

    // Determine source base branch to branch off from (prefer dev when it exists)
    let sourceBase: string = (repoData.default_branch as string) || 'main';
    try {
      const devUrl = `${repoUrl}/branches/dev`;
      const devRes = await fetch(devUrl, { headers: buildHeaders(token, false) });
      if (devRes.ok) sourceBase = 'dev';
    } catch {}

    // Derive a timestamp from the fix branch (fix/<timestamp>), fallback to now
    let ts = String(Date.now());
    try {
      const m = /^fix\/(\d+)/.exec(inputData.branch || '');
      if (m && m[1]) ts = m[1];
    } catch {}
    const newBaseBranch = `dev-${ts}`;

    // Create the new base branch refs/heads/dev-<timestamp> from sourceBase
    try {
      const refUrl = `${repoUrl}/git/ref/heads/${encodeURIComponent(sourceBase)}`;
      const refRes = await fetch(refUrl, { headers: buildHeaders(token, true) });
      await throwIfNotOk(refRes);
      const refData = await refRes.json();
      const baseSha: string = refData.object?.sha || refData.sha;

      const createRefUrl = `${repoUrl}/git/refs`;
      const createRes = await fetch(createRefUrl, {
        method: 'POST',
        headers: { ...buildHeaders(token, true), 'Content-Type': 'application/json' },
        body: JSON.stringify({ ref: `refs/heads/${newBaseBranch}`, sha: baseSha }),
      });
      if (!createRes.ok && createRes.status !== 422) {
        await throwIfNotOk(createRes);
      }
    } catch (err) {
      try { console.error('[samba/open-pr] create_base_branch_error', { err: String(err) }); } catch {}
      throw err;
    }

    const title = inputData.prTitle || 'fix: automated fix from stack trace';
    const body = inputData.prBody || 'Automated fix generated by workflow.';

    const prsUrl = `${repoUrl}/pulls`;
    const res = await fetch(prsUrl, {
      method: 'POST',
      headers: { ...buildHeaders(token, true), 'Content-Type': 'application/json' },
      body: JSON.stringify({ title, head: inputData.branch, base: newBaseBranch, body }),
    });
    await throwIfNotOk(res);
    const data = await res.json();
    const out = {
      runId: inputData.runId,
      owner: inputData.owner,
      repo: inputData.repo,
      branch: inputData.branch,
      token: inputData.token,
      number: data.number,
      url: data.html_url ?? data.url,
      state: data.state,
    };
    try { console.log('[samba/open-pr] out', out); } catch {}
    return out;
  },
});
